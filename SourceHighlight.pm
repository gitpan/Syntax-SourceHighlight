# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.

package Syntax::SourceHighlight;
use base qw(Exporter);
use base qw(DynaLoader);
package Syntax::SourceHighlightc;
bootstrap Syntax::SourceHighlight;
package Syntax::SourceHighlight;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Syntax::SourceHighlight;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Syntax::SourceHighlight;


############# Class : Syntax::SourceHighlight::HighlightToken ##############

package Syntax::SourceHighlight::HighlightToken;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Syntax::SourceHighlight );
%OWNER = ();
%ITERATORS = ();
*prefix = *Syntax::SourceHighlightc::HighlightToken_prefix;
*isPrefixOnlySpaces = *Syntax::SourceHighlightc::HighlightToken_isPrefixOnlySpaces;
*suffix = *Syntax::SourceHighlightc::HighlightToken_suffix;
*matchedSize = *Syntax::SourceHighlightc::HighlightToken_matchedSize;
*matched = *Syntax::SourceHighlightc::HighlightToken_matched;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Syntax::SourceHighlightc::delete_HighlightToken($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Syntax::SourceHighlight::HighlightEvent ##############

package Syntax::SourceHighlight::HighlightEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Syntax::SourceHighlight );
%OWNER = ();
%ITERATORS = ();
*FORMAT = *Syntax::SourceHighlightc::HighlightEvent_FORMAT;
*FORMATDEFAULT = *Syntax::SourceHighlightc::HighlightEvent_FORMATDEFAULT;
*ENTERSTATE = *Syntax::SourceHighlightc::HighlightEvent_ENTERSTATE;
*EXITSTATE = *Syntax::SourceHighlightc::HighlightEvent_EXITSTATE;
*token = *Syntax::SourceHighlightc::HighlightEvent_token;
*type = *Syntax::SourceHighlightc::HighlightEvent_type;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Syntax::SourceHighlightc::delete_HighlightEvent($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Syntax::SourceHighlight::SourceHighlight ##############

package Syntax::SourceHighlight::SourceHighlight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Syntax::SourceHighlight );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Syntax::SourceHighlightc::new_SourceHighlight(@_);
    bless $self, $pkg if defined($self);
}

*highlightFile = *Syntax::SourceHighlightc::SourceHighlight_highlightFile;
*checkLangDef = *Syntax::SourceHighlightc::SourceHighlight_checkLangDef;
*checkOutLangDef = *Syntax::SourceHighlightc::SourceHighlight_checkOutLangDef;
*createOutputFileName = *Syntax::SourceHighlightc::SourceHighlight_createOutputFileName;
*setDataDir = *Syntax::SourceHighlightc::SourceHighlight_setDataDir;
*setStyleFile = *Syntax::SourceHighlightc::SourceHighlight_setStyleFile;
*setStyleCssFile = *Syntax::SourceHighlightc::SourceHighlight_setStyleCssFile;
*setStyleDefaultFile = *Syntax::SourceHighlightc::SourceHighlight_setStyleDefaultFile;
*setTitle = *Syntax::SourceHighlightc::SourceHighlight_setTitle;
*setCss = *Syntax::SourceHighlightc::SourceHighlight_setCss;
*setHeaderFileName = *Syntax::SourceHighlightc::SourceHighlight_setHeaderFileName;
*setFooterFileName = *Syntax::SourceHighlightc::SourceHighlight_setFooterFileName;
*setOutputDir = *Syntax::SourceHighlightc::SourceHighlight_setOutputDir;
*setOptimize = *Syntax::SourceHighlightc::SourceHighlight_setOptimize;
*setGenerateLineNumbers = *Syntax::SourceHighlightc::SourceHighlight_setGenerateLineNumbers;
*setGenerateLineNumberRefs = *Syntax::SourceHighlightc::SourceHighlight_setGenerateLineNumberRefs;
*setLineNumberPad = *Syntax::SourceHighlightc::SourceHighlight_setLineNumberPad;
*setLineNumberAnchorPrefix = *Syntax::SourceHighlightc::SourceHighlight_setLineNumberAnchorPrefix;
*setGenerateEntireDoc = *Syntax::SourceHighlightc::SourceHighlight_setGenerateEntireDoc;
*setGenerateVersion = *Syntax::SourceHighlightc::SourceHighlight_setGenerateVersion;
*setCanUseStdOut = *Syntax::SourceHighlightc::SourceHighlight_setCanUseStdOut;
*setBinaryOutput = *Syntax::SourceHighlightc::SourceHighlight_setBinaryOutput;
*setHighlightEventListener = *Syntax::SourceHighlightc::SourceHighlight_setHighlightEventListener;
*setRangeSeparator = *Syntax::SourceHighlightc::SourceHighlight_setRangeSeparator;
*setTabSpaces = *Syntax::SourceHighlightc::SourceHighlight_setTabSpaces;
*highlightString = *Syntax::SourceHighlightc::SourceHighlight_highlightString;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Syntax::SourceHighlightc::delete_SourceHighlight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Syntax::SourceHighlight::LangMap ##############

package Syntax::SourceHighlight::LangMap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Syntax::SourceHighlight );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Syntax::SourceHighlightc::new_LangMap(@_);
    bless $self, $pkg if defined($self);
}

*getMappedFileName = *Syntax::SourceHighlightc::LangMap_getMappedFileName;
*getMappedFileNameFromFileName = *Syntax::SourceHighlightc::LangMap_getMappedFileNameFromFileName;
*langNames = *Syntax::SourceHighlightc::LangMap_langNames;
*mappedFileNames = *Syntax::SourceHighlightc::LangMap_mappedFileNames;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Syntax::SourceHighlightc::delete_LangMap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Syntax::SourceHighlight;



BEGIN {
  use File::Spec::Functions qw/catfile/;

  unless (exists $ENV{SOURCE_HIGHLIGHT_DATADIR}) {
    for (@INC) {
      my $data = catfile($_, 'Syntax', 'SourceHighlight');
      if (-d $data) {
	$ENV{SOURCE_HIGHLIGHT_DATADIR} = $data;
	last;
      }
    }
  }
}

our $VERSION = "1.1.2";
1;
